微服务之间有两种常见的通信方式：同步和异步。在同步通信中，调用方在发送下一条消息之前等待响应，并且它作为 HTTP 之上的 REST 协议运行。相反，在异步通信中，无需等待响应即可发送消息。这适用于分布式系统，通常需要消息代理来管理消息。

异步通信是非阻塞的。它也支持比同步操作更好的缩放

## RabbitMQ

AMQP（高级消息队列协议）的标准实现，部署相对比于其他简单一些。本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队。对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。

规模：根据配置和资源，这里的运行速度约为每秒 50K msg。

持久性：支持持久性消息和瞬时消息。

一对一与一对多的消费者：两者都有。

缺点：

Erlang 语言，目前用 Erlang 的还是少一些

## kafka

高吞吐量的分布式发布订阅消息系统。它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像 Hadoop 的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。

多用于实时性的处理

规模：每秒最多可以发送一百万条消息。

持久性：是的。

一对一 vs 一对多的消费者：只有一对多

- 吞吐量较低：Kafka 和 RabbitMQ 都可以。
- 吞吐量高：Kafka。
- 完全的分布式系统：Broker、Producer、Consumer 都原生自动支持分布式，依赖 zookeeper 自动实现复杂均衡；

缺点：

消费失败不支持重试

支持消息顺序，但是一台代理宕机后，就会产生消息乱序；

## ActiveMQ

## RocketMQ

阿里，因为内部产物，很多接口与 API 并不是普遍适用。参考 Kafka 设计的，

- 能够保证严格的消息顺序
- 提供针对消息的过滤功能
- 提供丰富的消息拉取模式
- 高效的订阅者水平扩展能力
- 实时的消息订阅机制
- 亿级消息堆积能力
